# 单例模式
单例模式最终目的是保证在系统中单例类只有**单一实例**, 为了实现这个目的一般有两种方式实现, 即饿汉式和懒汉式 

饿汉式和懒汉式最大的区别就是立即加载/延迟加载 

饿汉式在类加载的时候就已经完成了实例化并持有自身引用, 所以即使在多线程情况下依然能够保证线程安全; 

懒汉式则必须通过各种手段来实现**单一实例**这一最终目的

> 可以参考[如何正确地写出单例模式](http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/)

## 1.饿汉式
### 1.1 类加载单例(ClassloaderSingleton)
利用Java类加载机制实现单一实例并保证线程安全
```
优点: 实现简单, 天生线程安全
缺点: 在单例类被加载时就实例化并持有自身引用, 无法实现延迟加载(目的主要是实现降低初始化负载)
```
### 1.2 静态域单例(StaticFieldSingleton)
利用Java静态域在加载玩之后实例化, 保证线程安全
```
优点: 实现简单, 天生线程安全
缺点: 在单例类被加载后就实例化并持有自身引用, 无法实现延迟加载
```
### 1.3 枚举式(EnumSingleton)
```
优点: 1.线程安全 2.实现简单 3.JVM保证单个实例(在反序列化/反射等情况下)
缺点: 不常见
```

## 2.懒汉式
### 2.1 简单懒汉单例(SimpleSingleton)
线程不安全, 实际上算不上单例模式
```
优点: 实现简单, 能实现延迟加载
缺点: 线程不安全
```
### 2.2 同步方法单例(SyncSingleton)
利用同步方法实现单一实例, 保证线程安全
```
优点: 相比较基础的饿汉式单例而言, 具有了线程安全的特性
缺点: 同步方法粒度太大, 性能较差
```

### 2.3 双重检查单例(DoubleCheckSingleton)
利用同步方法块实现单一实例, 保证线程安全
```
优点: 相比较同步方法控制了加锁粒度, 性能比较好
缺点: 单例引用对象需要用volatile修饰, 这种安全隐患可能很难排查
```

## 3.序列化
除枚举式以外, 其他所有单例模式在涉及反序列化的时候都应该在类中添加一个`readResolve`方法, 并在方法中返回持有的实例
```
private Object readResolve() {     
    return getInstance();     
}  
```